# C89/C90 Grammar Definition
# Based on ANSI C (ISO/IEC 9899:1990)

# Start symbol
START: translation_unit

# Translation unit
translation_unit:
    external_declaration
    | translation_unit external_declaration
    ;

external_declaration:
    function_definition
    | declaration
    ;

# Function definitions
function_definition:
    declaration_specifiers declarator declaration_list compound_statement
    | declaration_specifiers declarator compound_statement
    | declarator declaration_list compound_statement
    | declarator compound_statement
    ;

declaration_list:
    declaration
    | declaration_list declaration
    ;

# Declarations
declaration:
    declaration_specifiers ';'
    | declaration_specifiers init_declarator_list ';'
    ;

declaration_specifiers:
    storage_class_specifier
    | storage_class_specifier declaration_specifiers
    | type_specifier
    | type_specifier declaration_specifiers
    | type_qualifier
    | type_qualifier declaration_specifiers
    ;

init_declarator_list:
    init_declarator
    | init_declarator_list ',' init_declarator
    ;

init_declarator:
    declarator
    | declarator '=' initializer
    ;

# Storage class specifiers
storage_class_specifier:
    'typedef'
    | 'extern'
    | 'static'
    | 'auto'
    | 'register'
    ;

# Type specifiers
type_specifier:
    'void'
    | 'char'
    | 'short'
    | 'int'
    | 'long'
    | 'float'
    | 'double'
    | 'signed'
    | 'unsigned'
    | struct_or_union_specifier
    | enum_specifier
    | typedef_name
    ;

struct_or_union_specifier:
    struct_or_union IDENTIFIER '{' struct_declaration_list '}'
    | struct_or_union '{' struct_declaration_list '}'
    | struct_or_union IDENTIFIER
    ;

struct_or_union:
    'struct'
    | 'union'
    ;

struct_declaration_list:
    struct_declaration
    | struct_declaration_list struct_declaration
    ;

struct_declaration:
    specifier_qualifier_list struct_declarator_list ';'
    ;

specifier_qualifier_list:
    type_specifier specifier_qualifier_list
    | type_specifier
    | type_qualifier specifier_qualifier_list
    | type_qualifier
    ;

struct_declarator_list:
    struct_declarator
    | struct_declarator_list ',' struct_declarator
    ;

struct_declarator:
    declarator
    | ':' constant_expression
    | declarator ':' constant_expression
    ;

enum_specifier:
    'enum' '{' enumerator_list '}'
    | 'enum' IDENTIFIER '{' enumerator_list '}'
    | 'enum' IDENTIFIER
    ;

enumerator_list:
    enumerator
    | enumerator_list ',' enumerator
    ;

enumerator:
    IDENTIFIER
    | IDENTIFIER '=' constant_expression
    ;

# Type qualifiers
type_qualifier:
    'const'
    | 'volatile'
    ;

# Declarators
declarator:
    pointer direct_declarator
    | direct_declarator
    ;

direct_declarator:
    IDENTIFIER
    | '(' declarator ')'
    | direct_declarator '[' constant_expression ']'
    | direct_declarator '[' ']'
    | direct_declarator '(' parameter_type_list ')'
    | direct_declarator '(' identifier_list ')'
    | direct_declarator '(' ')'
    ;

pointer:
    '*'
    | '*' type_qualifier_list
    | '*' pointer
    | '*' type_qualifier_list pointer
    ;

type_qualifier_list:
    type_qualifier
    | type_qualifier_list type_qualifier
    ;

parameter_type_list:
    parameter_list
    | parameter_list ',' '...'
    ;

parameter_list:
    parameter_declaration
    | parameter_list ',' parameter_declaration
    ;

parameter_declaration:
    declaration_specifiers declarator
    | declaration_specifiers abstract_declarator
    | declaration_specifiers
    ;

identifier_list:
    IDENTIFIER
    | identifier_list ',' IDENTIFIER
    ;

type_name:
    specifier_qualifier_list
    | specifier_qualifier_list abstract_declarator
    ;

abstract_declarator:
    pointer
    | direct_abstract_declarator
    | pointer direct_abstract_declarator
    ;

direct_abstract_declarator:
    '(' abstract_declarator ')'
    | '[' ']'
    | '[' constant_expression ']'
    | direct_abstract_declarator '[' ']'
    | direct_abstract_declarator '[' constant_expression ']'
    | '(' ')'
    | '(' parameter_type_list ')'
    | direct_abstract_declarator '(' ')'
    | direct_abstract_declarator '(' parameter_type_list ')'
    ;

typedef_name:
    IDENTIFIER
    ;

initializer:
    assignment_expression
    | '{' initializer_list '}'
    | '{' initializer_list ',' '}'
    ;

initializer_list:
    initializer
    | initializer_list ',' initializer
    ;

# Statements
statement:
    labeled_statement
    | compound_statement
    | expression_statement
    | selection_statement
    | iteration_statement
    | jump_statement
    ;

labeled_statement:
    IDENTIFIER ':' statement
    | 'case' constant_expression ':' statement
    | 'default' ':' statement
    ;

compound_statement:
    '{' '}'
    | '{' statement_list '}'
    | '{' declaration_list '}'
    | '{' declaration_list statement_list '}'
    ;

statement_list:
    statement
    | statement_list statement
    ;

expression_statement:
    ';'
    | expression ';'
    ;

selection_statement:
    'if' '(' expression ')' statement
    | 'if' '(' expression ')' statement 'else' statement
    | 'switch' '(' expression ')' statement
    ;

iteration_statement:
    'while' '(' expression ')' statement
    | 'do' statement 'while' '(' expression ')' ';'
    | 'for' '(' expression_statement expression_statement ')' statement
    | 'for' '(' expression_statement expression_statement expression ')' statement
    ;

jump_statement:
    'goto' IDENTIFIER ';'
    | 'continue' ';'
    | 'break' ';'
    | 'return' ';'
    | 'return' expression ';'
    ;

# Expressions
expression:
    assignment_expression
    | expression ',' assignment_expression
    ;

assignment_expression:
    conditional_expression
    | unary_expression assignment_operator assignment_expression
    ;

assignment_operator:
    '='
    | '*='
    | '/='
    | '%='
    | '+='
    | '-='
    | '<<='
    | '>>='
    | '&='
    | '^='
    | '|='
    ;

conditional_expression:
    logical_or_expression
    | logical_or_expression '?' expression ':' conditional_expression
    ;

constant_expression:
    conditional_expression
    ;

logical_or_expression:
    logical_and_expression
    | logical_or_expression '||' logical_and_expression
    ;

logical_and_expression:
    inclusive_or_expression
    | logical_and_expression '&&' inclusive_or_expression
    ;

inclusive_or_expression:
    exclusive_or_expression
    | inclusive_or_expression '|' exclusive_or_expression
    ;

exclusive_or_expression:
    and_expression
    | exclusive_or_expression '^' and_expression
    ;

and_expression:
    equality_expression
    | and_expression '&' equality_expression
    ;

equality_expression:
    relational_expression
    | equality_expression '==' relational_expression
    | equality_expression '!=' relational_expression
    ;

relational_expression:
    shift_expression
    | relational_expression '<' shift_expression
    | relational_expression '>' shift_expression
    | relational_expression '<=' shift_expression
    | relational_expression '>=' shift_expression
    ;

shift_expression:
    additive_expression
    | shift_expression '<<' additive_expression
    | shift_expression '>>' additive_expression
    ;

additive_expression:
    multiplicative_expression
    | additive_expression '+' multiplicative_expression
    | additive_expression '-' multiplicative_expression
    ;

multiplicative_expression:
    cast_expression
    | multiplicative_expression '*' cast_expression
    | multiplicative_expression '/' cast_expression
    | multiplicative_expression '%' cast_expression
    ;

cast_expression:
    unary_expression
    | '(' type_name ')' cast_expression
    ;

unary_expression:
    postfix_expression
    | '++' unary_expression
    | '--' unary_expression
    | unary_operator cast_expression
    | 'sizeof' unary_expression
    | 'sizeof' '(' type_name ')'
    ;

unary_operator:
    '&'
    | '*'
    | '+'
    | '-'
    | '~'
    | '!'
    ;

postfix_expression:
    primary_expression
    | postfix_expression '[' expression ']'
    | postfix_expression '(' ')'
    | postfix_expression '(' argument_expression_list ')'
    | postfix_expression '.' IDENTIFIER
    | postfix_expression '->' IDENTIFIER
    | postfix_expression '++'
    | postfix_expression '--'
    ;

primary_expression:
    IDENTIFIER
    | CONSTANT
    | STRING_LITERAL
    | '(' expression ')'
    ;

argument_expression_list:
    assignment_expression
    | argument_expression_list ',' assignment_expression
    ;

# Tokens
CONSTANT:
    INTEGER_CONSTANT
    | CHARACTER_CONSTANT
    | FLOATING_CONSTANT
    | ENUMERATION_CONSTANT
    ;

INTEGER_CONSTANT:
    DECIMAL_CONSTANT INTEGER_SUFFIX?
    | OCTAL_CONSTANT INTEGER_SUFFIX?
    | HEXADECIMAL_CONSTANT INTEGER_SUFFIX?
    ;

DECIMAL_CONSTANT:
    NONZERO_DIGIT DIGIT*
    ;

OCTAL_CONSTANT:
    '0' OCTAL_DIGIT*
    ;

HEXADECIMAL_CONSTANT:
    HEXADECIMAL_PREFIX HEXADECIMAL_DIGIT+
    ;

HEXADECIMAL_PREFIX:
    '0x'
    | '0X'
    ;

NONZERO_DIGIT:
    [1-9]
    ;

DIGIT:
    [0-9]
    ;

OCTAL_DIGIT:
    [0-7]
    ;

HEXADECIMAL_DIGIT:
    [0-9a-fA-F]
    ;

INTEGER_SUFFIX:
    UNSIGNED_SUFFIX LONG_SUFFIX?
    | LONG_SUFFIX UNSIGNED_SUFFIX?
    ;

UNSIGNED_SUFFIX:
    'u'
    | 'U'
    ;

LONG_SUFFIX:
    'l'
    | 'L'
    ;

CHARACTER_CONSTANT:
    '\'' C_CHAR_SEQUENCE '\''
    | 'L\'' C_CHAR_SEQUENCE '\''
    ;

C_CHAR_SEQUENCE:
    C_CHAR+
    ;

C_CHAR:
    [^'\\\n]
    | ESCAPE_SEQUENCE
    ;

ESCAPE_SEQUENCE:
    SIMPLE_ESCAPE_SEQUENCE
    | OCTAL_ESCAPE_SEQUENCE
    | HEXADECIMAL_ESCAPE_SEQUENCE
    ;

SIMPLE_ESCAPE_SEQUENCE:
    '\\'['\\\'"?abfnrtv]
    ;

OCTAL_ESCAPE_SEQUENCE:
    '\\' OCTAL_DIGIT
    | '\\' OCTAL_DIGIT OCTAL_DIGIT
    | '\\' OCTAL_DIGIT OCTAL_DIGIT OCTAL_DIGIT
    ;

HEXADECIMAL_ESCAPE_SEQUENCE:
    '\\x' HEXADECIMAL_DIGIT+
    ;

FLOATING_CONSTANT:
    FRACTIONAL_CONSTANT EXPONENT_PART? FLOATING_SUFFIX?
    | DIGIT_SEQUENCE EXPONENT_PART FLOATING_SUFFIX?
    ;

FRACTIONAL_CONSTANT:
    DIGIT_SEQUENCE? '.' DIGIT_SEQUENCE
    | DIGIT_SEQUENCE '.'
    ;

EXPONENT_PART:
    'e' SIGN? DIGIT_SEQUENCE
    | 'E' SIGN? DIGIT_SEQUENCE
    ;

SIGN:
    '+'
    | '-'
    ;

DIGIT_SEQUENCE:
    DIGIT+
    ;

FLOATING_SUFFIX:
    'f'
    | 'l'
    | 'F'
    | 'L'
    ;

ENUMERATION_CONSTANT:
    IDENTIFIER
    ;

STRING_LITERAL:
    '"' S_CHAR_SEQUENCE? '"'
    | 'L"' S_CHAR_SEQUENCE? '"'
    ;

S_CHAR_SEQUENCE:
    S_CHAR+
    ;

S_CHAR:
    [^"\\\n]
    | ESCAPE_SEQUENCE
    ;

IDENTIFIER:
    IDENTIFIER_NONDIGIT (IDENTIFIER_NONDIGIT | DIGIT)*
    ;

IDENTIFIER_NONDIGIT:
    NONDIGIT
    | UNIVERSAL_CHARACTER_NAME
    ;

NONDIGIT:
    [a-zA-Z_]
    ;

UNIVERSAL_CHARACTER_NAME:
    '\\u' HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT
    | '\\U' HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT HEXADECIMAL_DIGIT
    ;

specifier_qualifier_list:
    type_specifier specifier_qualifier_list
    | type_specifier
    | type_qualifier specifier_qualifier_list
    | type_qualifier
    ;

struct_declarator_list:
    struct_declarator
    | struct_declarator_list ',' struct_declarator
    ;

struct_declarator:
    declarator
    | ':' constant_expression
    | declarator ':' constant_expression
    ;

enum_specifier:
    'enum' '{' enumerator_list '}'
    | 'enum' IDENTIFIER '{' enumerator_list '}'
    | 'enum' IDENTIFIER
    ;

enumerator_list:
    enumerator
    | enumerator_list ',' enumerator
    ;

enumerator:
    IDENTIFIER
    | IDENTIFIER '=' constant_expression
    ;

# Type qualifiers
type_qualifier:
    'const'
    | 'volatile'
    ;

# Declarators
declarator:
    pointer direct_declarator
    | direct_declarator
    ;

direct_declarator:
    IDENTIFIER
    | '(' declarator ')'
    | direct_declarator '[' constant_expression ']'
    | direct_declarator '[' ']'
    | direct_declarator '(' parameter_type_list ')'
    | direct_declarator '(' identifier_list ')'
    | direct_declarator '(' ')'
    ;

pointer:
    '*'
    | '*' type_qualifier_list
    | '*' pointer
    | '*' type_qualifier_list pointer
    ;

type_qualifier_list:
    type_qualifier
    | type_qualifier_list type_qualifier
    ;

parameter_type_list:
    parameter_list
    | parameter_list ',' '...'
    ;

parameter_list:
    parameter_declaration
    | parameter_list ',' parameter_declaration
    ;

parameter_declaration:
    declaration_specifiers declarator
    | declaration_specifiers abstract_declarator
    | declaration_specifiers
    ;

identifier_list:
    IDENTIFIER
    | identifier_list ',' IDENTIFIER
    ;

type_name:
    specifier_qualifier_list
    | specifier_qualifier_list abstract_declarator
    ;

abstract_declarator:
    pointer
    | direct_abstract_declarator
    | pointer direct_abstract_declarator
    ;

direct_abstract_declarator:
    '(' abstract_declarator ')'
    | '[' ']'
    | '[' constant_expression ']'
    | direct_abstract_declarator '[' ']'
    | direct_abstract_declarator '[' constant_expression ']'
    | '(' ')'
    | '(' parameter_type_list ')'
    | direct_abstract_declarator '(' ')'
    | direct_abstract_declarator '(' parameter_type_list ')'
    ;

typedef_name:
    IDENTIFIER
    ;

# Initializers
initializer:
    assignment_expression
    | '{' initializer_list '}'
    | '{' initializer_list ',' '}'
    ;

initializer_list:
    initializer
    | initializer_list ',' initializer
    ;

# Statements
statement:
    labeled_statement
    | compound_statement
    | expression_statement
    | selection_statement
    | iteration_statement
    | jump_statement
    ;

labeled_statement:
    IDENTIFIER ':' statement
    | 'case' constant_expression ':' statement
    | 'default' ':' statement
    ;

compound_statement:
    '{' '}'
    | '{' statement_list '}'
    | '{' declaration_list '}'
    | '{' declaration_list statement_list '}'
    ;

statement_list:
    statement
    | statement_list statement
    ;

expression_statement:
    ';'
    | expression ';'
    ;

selection_statement:
    'if' '(' expression ')' statement
    | 'if' '(' expression ')' statement 'else' statement
    | 'switch' '(' expression ')' statement
    ;

iteration_statement:
    'while' '(' expression ')' statement
    | 'do' statement 'while' '(' expression ')' ';'
    | 'for' '(' expression_statement expression_statement ')' statement
    | 'for' '(' expression_statement expression_statement expression ')' statement
    ;

jump_statement:
    'goto' IDENTIFIER ';'
    | 'continue' ';'
    | 'break' ';'
    | 'return' ';'
    | 'return' expression ';'
    ;

# Expressions
expression:
    assignment_expression
    | expression ',' assignment_expression
    ;

assignment_expression:
    conditional_expression
    | unary_expression assignment_operator assignment_expression
    ;

assignment_operator:
    '='
    | '*='
    | '/='
    | '%='
    | '+='
    | '-='
    | '<<='
    | '>>='
    | '&='
    | '^='
    | '|='
    ;

conditional_expression:
    logical_or_expression
    | logical_or_expression '?' expression ':' conditional_expression
    ;

constant_expression:
    conditional_expression
    ;

logical_or_expression:
    logical_and_expression
    | logical_or_expression '||' logical_and_expression
    ;

logical_and_expression:
    inclusive_or_expression
    | logical_and_expression '&&' inclusive_or_expression
    ;

inclusive_or_expression:
    exclusive_or_expression
    | inclusive_or_expression '|' exclusive_or_expression
    ;

exclusive_or_expression:
    and_expression
    | exclusive_or_expression '^' and_expression
    ;

and_expression:
    equality_expression
    | and_expression '&' equality_expression
    ;

equality_expression:
    relational_expression
    | equality_expression '==' relational_expression
    | equality_expression '!=' relational_expression
    ;

relational_expression:
    shift_expression
    | relational_expression '<' shift_expression
    | relational_expression '>' shift_expression
    | relational_expression '<=' shift_expression
    | relational_expression '>=' shift_expression
    ;

shift_expression:
    additive_expression
    | shift_expression '<<' additive_expression
    | shift_expression '>>' additive_expression
    ;

additive_expression:
    multiplicative_expression
    | additive_expression '+' multiplicative_expression
    | additive_expression '-' multiplicative_expression
    ;

multiplicative_expression:
    cast_expression
    | multiplicative_expression '*' cast_expression
    | multiplicative_expression '/' cast_expression
    | multiplicative_expression '%' cast_expression
    ;

cast_expression:
    unary_expression
    | '(' type_name ')' cast_expression
    ;

unary_expression:
    postfix_expression
    | '++' unary_expression
    | '--' unary_expression
    | unary_operator cast_expression
    | 'sizeof' unary_expression
    | 'sizeof' '(' type_name ')'
    ;

unary_operator:
    '&'
    | '*'
    | '+'
    | '-'
    | '~'
    | '!'
    ;

postfix_expression:
    primary_expression
    | postfix_expression '[' expression ']'
    | postfix_expression '(' ')'
    | postfix_expression '(' argument_expression_list ')'
    | postfix_expression '.' IDENTIFIER
    | postfix_expression '->' IDENTIFIER
    | postfix_expression '++'
    | postfix_expression '--'
    ;

primary_expression:
    IDENTIFIER
    | CONSTANT
    | STRING_LITERAL
    | '(' expression ')'
    ;

argument_expression_list:
    assignment_expression
    | argument_expression_list ',' assignment_expression
    ;

# Terminals (tokens)
IDENTIFIER: [a-zA-Z_][a-zA-Z0-9_]*
CONSTANT: INTEGER_CONSTANT | CHARACTER_CONSTANT | FLOATING_CONSTANT | ENUMERATION_CONSTANT
STRING_LITERAL: "([^"\\]|\\.)*"
INTEGER_CONSTANT: [0-9]+[uUlL]*
CHARACTER_CONSTANT: '([^'\\]|\\.)+'
FLOATING_CONSTANT: [0-9]*\.[0-9]+([eE][+-]?[0-9]+)?[fFlL]?
ENUMERATION_CONSTANT: IDENTIFIER

# Keywords
KEYWORDS: auto break case char const continue default do double else enum extern float for goto if int long register return short signed sizeof static struct switch typedef union unsigned void volatile while

# Operators and punctuators
OPERATORS: + - * / % ++ -- & | ^ ~ ! << >> < > <= >= == != && || ? : = += -= *= /= %= &= |= ^= <<= >>= -> . [ ] ( ) { } , ; ...